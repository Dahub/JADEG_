@model JADEG.Model.PlayerModel

@{
    Layout = "~/Views/Shared/_Layout.cshtml";
}

@section scripts {
    <script src="/Scripts/Game/ressources.js"></script>
    <script src="/Scripts/Game/canvas.js"></script>
}

<div id="canvasDiv">
    <canvas id="canvas" width="600" height="600">
        Votre navigateur ne supporte pas canvas.
    </canvas>
</div>

<div id="xdiv"></div>
<div id="ydiv"></div>
<script type="text/javascript">

    var tile; // la case en cours
    var nextTile; // la prochaine case, lorsque le joueur en change
    var players = {}; // les joueurs présents sur la case, y compris le joueur actif

    $(document).ready(function () {
        var dungeonHub = $.connection.dungeonHub;
        $.connection.hub.start().done(function () {
            tile = loadNextTile(1, 0, 0);
            loadRessources(sources, function () {
                window.requestAnimFrame = (function () {
                    return window.requestAnimationFrame ||
                            window.webkitRequestAnimationFrame ||
                            window.mozRequestAnimationFrame ||
                            function (callback) {
                                window.setTimeout(callback, 1000 / 60);
                            };
                })();
                (function start() {
                    requestAnimFrame(start);
                    refreshCanvas('@Model.Name', '@Model.DungeonId');
                })();
            });

            // on rejoins la tile
            dungeonHub.server.joinTile('@Model.DungeonId', tile.XCoord, tile.YCoord, '@Model.Name', 7 * pitch, 2 * pitch);

            // on écoute les touches pressées sur le canvas
            $("#canvas").attr("tabindex", "0").mousedown(function () {
                $(this).focus(); return false;
            }).keydown(function (e) {
                keyPressedOnCanvas(e, '@Model.Name', '@Model.DungeonId');
            });
        });
    });

    $.connection.dungeonHub.client.newPlayerJoin = function (name, posX, posY) {
        console.log('un joueur arrive : ' + name + ' - x: ' + posX + ' y: ' + posY);
        players[name] = { x: posX, y: posY, toGox: posX, toGoy: posY };
    };

    $.connection.dungeonHub.client.playerQuit = function (name) {
        console.log('un joueur part : ' + name);
        delete players[name]
    }

    $.connection.dungeonHub.client.movePlayer = function (name, toGoX, toGoY) {
        players[name].toGox = toGoX;
        players[name].toGoy = toGoY;
    }

    function loadNextTile(dungeonId, x, y) {
        var model = { DungeonId: dungeonId, XCoord: x, YCoord: y };
        var toReturn;
        $.ajax({
            url: '/Tile/LoadTile',
            cache: false,
            async: false,
            data: JSON.stringify(model),
            type: 'POST',
            dataType: "json",
            contentType: 'application/json; charset=utf-8'
        }).done(function (data) {
            $('#xdiv').html(data.XCoord);
            $('#ydiv').html(data.YCoord);
            if (typeof (tile) != 'undefined') {
                $.connection.dungeonHub.server.quitTile(tile.DungeonId, tile.XCoord, tile.YCoord, '@Model.Name');
            }
            toReturn = data;
        });
        return toReturn;
    }
</script>

@*<script type="text/javascript">

        var pitchNumbers = 600;
        var size = 600;
        var pitch = Math.round(size / pitchNumbers);
        var ticker;
        var canvas = document.querySelector('#canvas');
        var context = canvas.getContext('2d');
        var playerSize = 40;
        var playerSpeed = 3;

        var ressources = {};
        var sources = {
            nesw: '/Images/nesw.svg',
            e: '/Images/e.svg',
            es: '/Images/es.svg',
            esw: '/Images/esw.svg',
            ew: '/Images/ew.svg',
            n: '/Images/n.svg',
            ne: '/Images/ne.svg',
            nes: '/Images/nes.svg',
            new: '/Images/new.svg',
            ns: '/Images/ns.svg',
            nsw: '/Images/nsw.svg',
            s: '/Images/s.svg',
            sw: '/Images/sw.svg',
            w: '/Images/w.svg',
            wn: '/Images/wn.svg',
        }

        var tile; // la case en cours
        var nextTile; // la prochaine case, lorsque le joueur en change

        var otherPlayers = {};

        var canvasOrigin = { x: 0, y: 0 };
        var playerPosition = { x: Math.round(300 / playerSpeed) * playerSpeed, y: Math.round(120 / playerSpeed) * playerSpeed };
        var toGoPosition = { x: playerPosition.x, y: playerPosition.y }

        var tileMove = { tileLoaded: false, N: false, E: false, S: false, W: false }

        $(document).ready(function () {

            var dungeonHub = $.connection.dungeonHub;
            $.connection.hub.start().done(function () {
                tile = loadNextTile(1, 0, 0);
                loadRessources(sources, function () {
                    window.requestAnimFrame = (function () {
                        return window.requestAnimationFrame ||
                                window.webkitRequestAnimationFrame ||
                                window.mozRequestAnimationFrame ||
                                function (callback) {
                                    window.setTimeout(callback, 1000 / 60);
                                };
                    })();
                    (function start() {
                        requestAnimFrame(start);
                        refreshCanvas();
                    })();
                });
            });

            $('#canvasDiv').click(function (evt) {
                if (tileMove.N !== true && tileMove.S !== true && tileMove.E !== true && tileMove.W !== true) {
                    var rect = canvas.getBoundingClientRect();
                    var xcord = evt.clientX - rect.left
                    var ycord = evt.clientY - rect.top;

                    toGoPosition.x = Math.round(Math.round((xcord / pitch) / playerSpeed) * playerSpeed);
                    toGoPosition.y = Math.round(Math.round((ycord / pitch) / playerSpeed) * playerSpeed);
                }
            });

            dungeonHub.client.movePlayer = function (name, posX, posY) {
                //   console.log(name + ' - x: ' + posX + ' y: ' + posY);
                otherPlayers[name].x = posX;
                otherPlayers[name].y = posY;
            };

            dungeonHub.client.newPlayerJoin = function (name, posX, posY) {
                //    console.log('un joueur arrive : ' + name + ' - x: ' + posX + ' y: ' + posY);
                otherPlayers[name] = { x: posX, y: posY };
            };

            dungeonHub.client.playerQuit = function (name) {
                //   console.log('un joueur part : ' + name);
                delete otherPlayers[name];
            }
        });

        function loadRessources(sources, callback) {
            var loadedImages = 0;
            var numImages = 0;

            for (var s in sources) {
                numImages++;
            }
            for (var src in sources) {
                ressources[src] = new Image();
                ressources[src].onload = function () {
                    if (++loadedImages >= numImages) {
                        callback(ressources);
                    }
                };
                ressources[src].src = sources[src];
            }
        }

        function refreshCanvas() {

            calcPlayerPosition();
            checkTileChange();

            context.clearRect(0, 0, size, size);

            context.drawImage(ressources[tile.Background], canvasOrigin.x * pitch, canvasOrigin.y * pitch, size, size);
            if (tileMove.E === true && typeof nextTile != 'undefined') {
                context.drawImage(ressources[nextTile.Background], size + canvasOrigin.x * pitch, canvasOrigin.y * pitch, size, size);
            }
            else if (tileMove.W === true && typeof nextTile != 'undefined') {
                context.drawImage(ressources[nextTile.Background], canvasOrigin.x * pitch - size, canvasOrigin.y * pitch, size, size);
            }
            else if (tileMove.N === true && typeof nextTile != 'undefined') {
                context.drawImage(ressources[nextTile.Background], canvasOrigin.x * pitch, canvasOrigin.y * pitch - size, size, size);
            }
            else if (tileMove.S === true && typeof nextTile != 'undefined') {
                context.drawImage(ressources[nextTile.Background], canvasOrigin.x * pitch, size + canvasOrigin.y * pitch, size, size);
            }

            // on trace le player
            context.fillStyle = '#000000';
            context.fillRect(
                playerPosition.x * pitch - playerSize * pitch / 2,
                playerPosition.y * pitch - playerSize * pitch / 2,
                playerSize * pitch,
                playerSize * pitch);

            // on trace les autres joueurs
            context.fillStyle = '#FF0000';
            for (key in otherPlayers) {
                var o = otherPlayers[key];
                context.fillRect(
                     o.x * pitch - playerSize * pitch / 2,
                     o.y * pitch - playerSize * pitch / 2,
                     playerSize * pitch,
                     playerSize * pitch);
            }
        }

        function checkTileChange() {
            // on vérifie qu'on est dans une zone de sortie
            if (playerPosition.x >= pitchNumbers - playerSize) {
                tileMove.E = true;
            }
            else if (playerPosition.x <= playerSize) {
                tileMove.W = true;
            }
            else if (playerPosition.y <= playerSize) {
                tileMove.N = true;
            }
            else if (playerPosition.y >= pitchNumbers - playerSize) {
                tileMove.S = true;
            }

            if (tileMove.tileLoaded === false && (tileMove.E === true || tileMove.W || true && tileMove.N === true || tileMove.S === true)) {
                var x = tile.XCoord;
                var y = tile.YCoord;
                if (tileMove.E === true)
                    x += 1;
                if (tileMove.W === true)
                    x -= 1;
                if (tileMove.N === true)
                    y += 1;
                if (tileMove.S === true)
                    y -= 1;

                nextTile = loadNextTile(tile.DungeonId, x, y);
                tileMove.tileLoaded = true;
            }

            if (tileMove.E === true) {
                canvasOrigin.x -= 10 * pitch;
                playerPosition.x -= 8 * pitch;
            }
            else if (tileMove.W === true) {
                canvasOrigin.x += 10 * pitch;
                playerPosition.x += 8 * pitch;
            }
            else if (tileMove.N === true) {
                canvasOrigin.y += 10 * pitch;
                playerPosition.y += 8 * pitch;
            }
            else if (tileMove.S === true) {
                canvasOrigin.y -= 10 * pitch;
                playerPosition.y -= 8 * pitch;
            }

            if (tileMove.E === true || tileMove.W || true && tileMove.N === true || tileMove.S === true) {
                canvasOrigin.x = Math.round(canvasOrigin.x);
                canvasOrigin.y = Math.round(canvasOrigin.y);

                if (Math.abs(canvasOrigin.x) > pitchNumbers || Math.abs(canvasOrigin.y) > pitchNumbers) {
                    tileMove.E = false;
                    tileMove.W = false;
                    tileMove.N = false;
                    tileMove.S = false;
                    canvasOrigin.x = 0;
                    canvasOrigin.y = 0;
                    playerPosition.x = Math.round(Math.round(playerPosition.x / playerSpeed) * playerSpeed);
                    playerPosition.y = Math.round(Math.round(playerPosition.y / playerSpeed) * playerSpeed);
                    toGoPosition.x = playerPosition.x;
                    toGoPosition.y = playerPosition.y;
                    tileMove.tileLoaded = false;
                    tile = nextTile;
                    nextTile = null;
                }
            }
        }

        function calcPlayerPosition() {
            if (tileMove.N !== true && tileMove.S !== true && tileMove.E !== true && tileMove.W !== true) {
                var moving = false;
                if (toGoPosition.x > playerPosition.x) { // déplacement vers l'est
                    var delta = checkCollision(playerPosition.x, playerPosition.y, 1, 0, playerSpeed, playerSize);
                    playerPosition.x += delta
                    if (playerPosition.x >= toGoPosition.x) {
                        playerPosition.x = toGoPosition.x;
                    }
                    if (delta > 0) {
                        moving = true;
                    }
                }
                else if (toGoPosition.x < playerPosition.x) {
                    var delta = checkCollision(playerPosition.x, playerPosition.y, -1, 0, playerSpeed, playerSize);
                    playerPosition.x -= delta;
                    if (playerPosition.x < toGoPosition.x) {
                        playerPosition.x = toGoPosition.x;
                    }
                    if (delta > 0) {
                        moving = true;
                    }
                }

                if (toGoPosition.y > playerPosition.y) {
                    var delta = checkCollision(playerPosition.x, playerPosition.y, 0, 1, playerSpeed, playerSize);
                    playerPosition.y += delta;
                    if (playerPosition.y > toGoPosition.y) {
                        playerPosition.y = toGoPosition.y
                    }
                    if (delta > 0) {
                        moving = true;
                    }
                }
                else if (toGoPosition.y < playerPosition.y) {
                    var delta = checkCollision(playerPosition.x, playerPosition.y, 0, -1, playerSpeed, playerSize);
                    playerPosition.y -= delta;
                    if (playerPosition.y < toGoPosition.y) {
                        playerPosition.y = toGoPosition.y
                    }
                    if (delta > 0) {
                        moving = true;
                    }
                }

                if (moving === false) {
                    playerPosition.x = Math.round(Math.round(playerPosition.x / playerSpeed) * playerSpeed);
                    playerPosition.y = Math.round(Math.round(playerPosition.y / playerSpeed) * playerSpeed);
                    toGoPosition.x = playerPosition.x;
                    toGoPosition.y = playerPosition.y;
                }
                else {
                    $.connection.dungeonHub.server.move('@Model.Name', playerPosition.x, playerPosition.y, tile.DungeonId, tile.XCoord, tile.YCoord);
                }
            }
        }

        function checkCollision(startX, startY, directionX, directionY, speed, objectSize) {
            var padding = objectSize / 2;
            var collision = false;
            var x = startX + (speed * directionX); // position finale en X
            var y = startY + (speed * directionY); // position finale en Y
            var concernedWall;
            $.each(tile.Walls, function (i, val) {
                if (x < val.EndX + padding
                  && x > val.StartX - padding
                  && y > val.StartY - padding
                  && y < val.EndY + padding) {
                    concernedWall = val;
                    collision = true;
                    return false;
                }
            });

            if (collision === true) {
                if (directionX > 0 && x > concernedWall.StartX - padding) { // on va vers l'est
                    speed = concernedWall.StartX - startX - padding;
                }
                else if (directionX < 0 && x < concernedWall.EndX + padding) { // on va vers l'ouest
                    speed = startX - concernedWall.EndX - padding;
                }
                if (directionY > 0 && y > concernedWall.StartY - padding) {
                    speed = concernedWall.StartY - startY - padding;
                }
                else if (directionY < 0 && y < concernedWall.EndY + padding) {
                    speed = startY - concernedWall.EndY - padding;
                }
            }
            return speed;
        }

        function checkIfInWall(x, y) {
            var result = false;
            var padding = playerSize / 2;

            $.each(tile.Walls, function (i, val) {
                if (x < val.EndX + padding
                    && x > val.StartX - padding
                    && y > val.StartY - padding
                    && y < val.EndY + padding) {
                    result = true;
                    return false;
                }
                else if (x < 0 + padding // limites de case
                        || x > pitchNumbers - padding
                        || y < 0 + padding
                        || y > pitchNumbers - padding) {
                    result = true;
                    return false;
                }
            });
            return result;
        }

        function loadNextTile(dungeonId, x, y) {
            var model = { DungeonId: dungeonId, XCoord: x, YCoord: y };
            var toReturn;
            $.ajax({
                url: '/Tile/LoadTile',
                cache: false,
                async: false,
                data: JSON.stringify(model),
                type: 'POST',
                dataType: "json",
                contentType: 'application/json; charset=utf-8'
            }).done(function (data) {
                $('#xdiv').html(data.XCoord);
                $('#ydiv').html(data.YCoord);
                if (typeof (tile) != 'undefined') {
                    $.connection.dungeonHub.server.quitTile(tile.DungeonId, tile.XCoord, tile.YCoord, '@Model.Name');
                }
                $.connection.dungeonHub.server.joinTile(data.DungeonId, data.XCoord, data.YCoord, '@Model.Name', playerPosition.x, playerPosition.y);
                toReturn = data;
            });
            return toReturn;
        }

    </script>*@
